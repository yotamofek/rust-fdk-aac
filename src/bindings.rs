/* automatically generated by rust-bindgen */

pub const SHORT_BITS: u32 = 16;
pub const CHAR_BITS: u32 = 8;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const WAV_BITS: u32 = 16;
pub const SAMPLE_BITS: u32 = 16;
pub const ALIGNMENT_DEFAULT: u32 = 8;
pub const ALIGNMENT_EXTRES: u32 = 8;
pub const M_PI: f64 = 3.141592653589793;
pub const FDK_EXITCODE_OK: u32 = 0;
pub const FDK_EXITCODE_USAGE: u32 = 64;
pub const FDK_EXITCODE_DATAERROR: u32 = 65;
pub const FDK_EXITCODE_NOINPUT: u32 = 66;
pub const FDK_EXITCODE_UNAVAILABLE: u32 = 69;
pub const FDK_EXITCODE_SOFTWARE: u32 = 70;
pub const FDK_EXITCODE_CANTCREATE: u32 = 73;
pub const FDK_EXITCODE_IOERROR: u32 = 74;
pub const FDK_MAX_OVERLAYS: u32 = 8;
pub const AC_ER_VCB11: u32 = 1;
pub const AC_ER_RVLC: u32 = 2;
pub const AC_ER_HCR: u32 = 4;
pub const AC_SCALABLE: u32 = 8;
pub const AC_ELD: u32 = 16;
pub const AC_LD: u32 = 32;
pub const AC_ER: u32 = 64;
pub const AC_BSAC: u32 = 128;
pub const AC_USAC: u32 = 256;
pub const AC_RSV603DA: u32 = 512;
pub const AC_HDAAC: u32 = 1024;
pub const AC_RSVD50: u32 = 16384;
pub const AC_SBR_PRESENT: u32 = 32768;
pub const AC_SBRCRC: u32 = 65536;
pub const AC_PS_PRESENT: u32 = 131072;
pub const AC_MPS_PRESENT: u32 = 262144;
pub const AC_DRM: u32 = 524288;
pub const AC_INDEP: u32 = 1048576;
pub const AC_MPEGD_RES: u32 = 2097152;
pub const AC_SAOC_PRESENT: u32 = 4194304;
pub const AC_DAB: u32 = 8388608;
pub const AC_ELD_DOWNSCALE: u32 = 16777216;
pub const AC_LD_MPS: u32 = 33554432;
pub const AC_DRC_PRESENT: u32 = 67108864;
pub const AC_USAC_SCFGI3: u32 = 134217728;
pub const AC_CM_DET_CFG_CHANGE: u32 = 1;
pub const AC_CM_ALLOC_MEM: u32 = 2;
pub const AC_EL_USAC_TW: u32 = 1;
pub const AC_EL_USAC_NOISE: u32 = 2;
pub const AC_EL_USAC_ITES: u32 = 4;
pub const AC_EL_USAC_PVC: u32 = 8;
pub const AC_EL_USAC_MPS212: u32 = 16;
pub const AC_EL_USAC_LFE: u32 = 32;
pub const AC_EL_USAC_CP_POSSIBLE: u32 = 64;
pub const AC_EL_ENHANCED_NOISE: u32 = 128;
pub const AC_EL_IGF_AFTER_TNS: u32 = 256;
pub const AC_EL_IGF_INDEP_TILING: u32 = 512;
pub const AC_EL_IGF_USE_ENF: u32 = 1024;
pub const AC_EL_FULLBANDLPD: u32 = 2048;
pub const AC_EL_LPDSTEREOIDX: u32 = 4096;
pub const AC_EL_LFE: u32 = 8192;
pub const CC_MPEG_ID: u32 = 1048576;
pub const CC_IS_BASELAYER: u32 = 2097152;
pub const CC_PROTECTION: u32 = 4194304;
pub const CC_SBR: u32 = 8388608;
pub const CC_SBRCRC: u32 = 65536;
pub const CC_SAC: u32 = 131072;
pub const CC_RVLC: u32 = 16777216;
pub const CC_VCB11: u32 = 33554432;
pub const CC_HCR: u32 = 67108864;
pub const CC_PSEUDO_SURROUND: u32 = 134217728;
pub const CC_USAC_NOISE: u32 = 268435456;
pub const CC_USAC_TW: u32 = 536870912;
pub const CC_USAC_HBE: u32 = 1073741824;
pub const USAC_ID_BIT: u32 = 16;
pub const EXT_ID_BITS: u32 = 4;
pub const CAPF_AAC_LC: u32 = 1;
pub const CAPF_ER_AAC_LD: u32 = 2;
pub const CAPF_ER_AAC_SCAL: u32 = 4;
pub const CAPF_ER_AAC_LC: u32 = 8;
pub const CAPF_AAC_480: u32 = 16;
pub const CAPF_AAC_512: u32 = 32;
pub const CAPF_AAC_960: u32 = 64;
pub const CAPF_AAC_1024: u32 = 128;
pub const CAPF_AAC_HCR: u32 = 256;
pub const CAPF_AAC_VCB11: u32 = 512;
pub const CAPF_AAC_RVLC: u32 = 1024;
pub const CAPF_AAC_MPEG4: u32 = 2048;
pub const CAPF_AAC_DRC: u32 = 4096;
pub const CAPF_AAC_CONCEALMENT: u32 = 8192;
pub const CAPF_AAC_DRM_BSFORMAT: u32 = 16384;
pub const CAPF_ER_AAC_ELD: u32 = 32768;
pub const CAPF_ER_AAC_BSAC: u32 = 65536;
pub const CAPF_AAC_ELD_DOWNSCALE: u32 = 262144;
pub const CAPF_AAC_USAC_LP: u32 = 1048576;
pub const CAPF_AAC_USAC: u32 = 2097152;
pub const CAPF_ER_AAC_ELDV2: u32 = 8388608;
pub const CAPF_AAC_UNIDRC: u32 = 16777216;
pub const CAPF_ADTS: u32 = 1;
pub const CAPF_ADIF: u32 = 2;
pub const CAPF_LATM: u32 = 4;
pub const CAPF_LOAS: u32 = 8;
pub const CAPF_RAWPACKETS: u32 = 16;
pub const CAPF_DRM: u32 = 32;
pub const CAPF_RSVD50: u32 = 64;
pub const CAPF_SBR_LP: u32 = 1;
pub const CAPF_SBR_HQ: u32 = 2;
pub const CAPF_SBR_DRM_BS: u32 = 4;
pub const CAPF_SBR_CONCEALMENT: u32 = 8;
pub const CAPF_SBR_DRC: u32 = 16;
pub const CAPF_SBR_PS_MPEG: u32 = 32;
pub const CAPF_SBR_PS_DRM: u32 = 64;
pub const CAPF_SBR_ELD_DOWNSCALE: u32 = 128;
pub const CAPF_SBR_HBEHQ: u32 = 256;
pub const CAPF_DMX_BLIND: u32 = 1;
pub const CAPF_DMX_PCE: u32 = 2;
pub const CAPF_DMX_ARIB: u32 = 4;
pub const CAPF_DMX_DVB: u32 = 8;
pub const CAPF_DMX_CH_EXP: u32 = 16;
pub const CAPF_DMX_6_CH: u32 = 32;
pub const CAPF_DMX_8_CH: u32 = 64;
pub const CAPF_DMX_24_CH: u32 = 128;
pub const CAPF_LIMITER: u32 = 8192;
pub const CAPF_MPS_STD: u32 = 1;
pub const CAPF_MPS_LD: u32 = 2;
pub const CAPF_MPS_USAC: u32 = 4;
pub const CAPF_MPS_HQ: u32 = 16;
pub const CAPF_MPS_LP: u32 = 32;
pub const CAPF_MPS_BLIND: u32 = 64;
pub const CAPF_MPS_BINAURAL: u32 = 128;
pub const CAPF_MPS_2CH_OUT: u32 = 256;
pub const CAPF_MPS_6CH_OUT: u32 = 512;
pub const CAPF_MPS_8CH_OUT: u32 = 1024;
pub const CAPF_MPS_1CH_IN: u32 = 4096;
pub const CAPF_MPS_2CH_IN: u32 = 8192;
pub const CAPF_MPS_6CH_IN: u32 = 16384;
pub const AACENCODER_LIB_VL0: u32 = 4;
pub const AACENCODER_LIB_VL1: u32 = 0;
pub const AACENCODER_LIB_VL2: u32 = 0;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
#[doc = " \\var  SCHAR"]
#[doc = "        Data type representing at least 1 byte signed integer on all supported"]
#[doc = " platforms."]
#[doc = "        Data type representing at least 1 byte unsigned integer on all"]
#[doc = " supported platforms."]
#[doc = "        Data type representing at least 4 byte signed integer on all supported"]
#[doc = " platforms."]
#[doc = "        Data type representing at least 4 byte unsigned integer on all"]
#[doc = " supported platforms."]
#[doc = "        Data type representing 4 byte signed integer on all supported"]
#[doc = " platforms."]
#[doc = "        Data type representing 4 byte unsigned integer on all supported"]
#[doc = " platforms."]
#[doc = "        Data type representing 2 byte signed integer on all supported"]
#[doc = " platforms."]
#[doc = "        Data type representing 2 byte unsigned integer on all supported"]
#[doc = " platforms."]
#[doc = "        Data type representing 8 byte signed integer on all supported"]
#[doc = " platforms."]
#[doc = "        Data type representing 8 byte unsigned integer on all supported"]
#[doc = " platforms."]
#[doc = "        Number of bits the data type short represents. sizeof() is not suited"]
#[doc = " to get this info, because a byte is not always defined as 8 bits."]
#[doc = "        Number of bits the data type char represents. sizeof() is not suited"]
#[doc = " to get this info, because a byte is not always defined as 8 bits."]
#[doc = "        Data type representing the width of input and output PCM samples."]
pub type INT = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type SHORT = ::std::os::raw::c_short;
pub type USHORT = ::std::os::raw::c_ushort;
pub type SCHAR = ::std::os::raw::c_schar;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type INT64 = ::std::os::raw::c_longlong;
pub type UINT64 = ::std::os::raw::c_ulonglong;
extern "C" {
    #[link_name = "\u{1}___assert_rtn"]
    pub fn __assert_rtn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    );
}
pub type INT_PCM = SHORT;
pub const MEMORY_SECTION_SECT_DATA_L1: MEMORY_SECTION = 8192;
pub const MEMORY_SECTION_SECT_DATA_L2: MEMORY_SECTION = 8193;
pub const MEMORY_SECTION_SECT_DATA_L1_A: MEMORY_SECTION = 8194;
pub const MEMORY_SECTION_SECT_DATA_L1_B: MEMORY_SECTION = 8195;
pub const MEMORY_SECTION_SECT_CONSTDATA_L1: MEMORY_SECTION = 8196;
pub const MEMORY_SECTION_SECT_DATA_EXTERN: MEMORY_SECTION = 16384;
pub const MEMORY_SECTION_SECT_CONSTDATA_EXTERN: MEMORY_SECTION = 16385;
#[doc = " Identifiers for various memory locations. They are used along with memory"]
#[doc = " allocation functions like FDKcalloc_L() to specify the requested memory\'s"]
#[doc = " location."]
pub type MEMORY_SECTION = u32;
extern "C" {
    #[link_name = "\u{1}_FDKprintf"]
    pub fn FDKprintf(szFmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}_FDKprintfErr"]
    pub fn FDKprintfErr(szFmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " Wrapper for <stdio.h>\'s getchar()."]
    #[link_name = "\u{1}_FDKgetchar"]
    pub fn FDKgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_FDKfprintf"]
    pub fn FDKfprintf(
        stream: *mut ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> INT;
}
extern "C" {
    #[link_name = "\u{1}_FDKsprintf"]
    pub fn FDKsprintf(
        str: *mut ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> INT;
}
extern "C" {
    #[link_name = "\u{1}_FDKstrchr"]
    pub fn FDKstrchr(s: *mut ::std::os::raw::c_char, c: INT) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_FDKstrstr"]
    pub fn FDKstrstr(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_FDKstrcpy"]
    pub fn FDKstrcpy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_FDKstrncpy"]
    pub fn FDKstrncpy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        n: UINT,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_FDKcalloc"]
    pub fn FDKcalloc(n: UINT, size: UINT) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_FDKmalloc"]
    pub fn FDKmalloc(size: UINT) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_FDKfree"]
    pub fn FDKfree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  Allocate and clear an aligned memory area. Use FDKafree() instead of"]
    #[doc = " FDKfree() for these memory areas."]
    #[doc = ""]
    #[doc = " \\param size       Size of requested memory in bytes."]
    #[doc = " \\param alignment  Alignment of requested memory in bytes."]
    #[doc = " \\return           Pointer to allocated memory."]
    #[link_name = "\u{1}_FDKaalloc"]
    pub fn FDKaalloc(size: UINT, alignment: UINT) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  Free an aligned memory area."]
    #[doc = ""]
    #[doc = " \\param ptr  Pointer to be freed."]
    #[link_name = "\u{1}_FDKafree"]
    pub fn FDKafree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  Allocate memory in a specific memory section."]
    #[doc = "  Requests can be made for internal or external memory. If internal memory is"]
    #[doc = "  requested, FDKcalloc_L() first tries to use L1 memory, which sizes are"]
    #[doc = " defined by ::DATA_L1_A_SIZE and ::DATA_L1_B_SIZE. If no L1 memory is"]
    #[doc = " available, then FDKcalloc_L() tries to use L2 memory. If that fails as well,"]
    #[doc = " the requested memory is allocated at an extern location using the fallback"]
    #[doc = " FDKcalloc()."]
    #[doc = ""]
    #[doc = " \\param n     See MSDN documentation on calloc()."]
    #[doc = " \\param size  See MSDN documentation on calloc()."]
    #[doc = " \\param s     Memory section."]
    #[doc = " \\return      See MSDN documentation on calloc()."]
    #[link_name = "\u{1}_FDKcalloc_L"]
    pub fn FDKcalloc_L(n: UINT, size: UINT, s: MEMORY_SECTION) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  Allocate aligned memory in a specific memory section."]
    #[doc = "  See FDKcalloc_L() description for details - same applies here."]
    #[link_name = "\u{1}_FDKaalloc_L"]
    pub fn FDKaalloc_L(
        size: UINT,
        alignment: UINT,
        s: MEMORY_SECTION,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "  Free memory that was allocated in a specific memory section."]
    #[link_name = "\u{1}_FDKfree_L"]
    pub fn FDKfree_L(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "  Free aligned memory that was allocated in a specific memory section."]
    #[link_name = "\u{1}_FDKafree_L"]
    pub fn FDKafree_L(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Copy memory. Source and destination memory must not overlap."]
    #[doc = " Either use implementation from a Standard Library, or, if no Standard Library"]
    #[doc = " is available, a generic implementation."]
    #[doc = " The define ::USE_BUILTIN_MEM_FUNCTIONS in genericStds.cpp controls what to"]
    #[doc = " use. The function arguments correspond to the standard memcpy(). Please see"]
    #[doc = " MSDN documentation for details on how to use it."]
    #[link_name = "\u{1}_FDKmemcpy"]
    pub fn FDKmemcpy(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        size: UINT,
    );
}
extern "C" {
    #[doc = " Copy memory. Source and destination memory are allowed to overlap."]
    #[doc = " Either use implementation from a Standard Library, or, if no Standard Library"]
    #[doc = " is available, a generic implementation."]
    #[doc = " The define ::USE_BUILTIN_MEM_FUNCTIONS in genericStds.cpp controls what to"]
    #[doc = " use. The function arguments correspond to the standard memmove(). Please see"]
    #[doc = " MSDN documentation for details on how to use it."]
    #[link_name = "\u{1}_FDKmemmove"]
    pub fn FDKmemmove(
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
        size: UINT,
    );
}
extern "C" {
    #[doc = " Clear memory."]
    #[doc = " Either use implementation from a Standard Library, or, if no Standard Library"]
    #[doc = " is available, a generic implementation."]
    #[doc = " The define ::USE_BUILTIN_MEM_FUNCTIONS in genericStds.cpp controls what to"]
    #[doc = " use. The function arguments correspond to the standard memclear(). Please see"]
    #[doc = " MSDN documentation for details on how to use it."]
    #[link_name = "\u{1}_FDKmemclear"]
    pub fn FDKmemclear(memPtr: *mut ::std::os::raw::c_void, size: UINT);
}
extern "C" {
    #[doc = " Fill memory with values."]
    #[doc = " The function arguments correspond to the standard memset(). Please see MSDN"]
    #[doc = " documentation for details on how to use it."]
    #[link_name = "\u{1}_FDKmemset"]
    pub fn FDKmemset(memPtr: *mut ::std::os::raw::c_void, value: INT, size: UINT);
}
extern "C" {
    #[link_name = "\u{1}_FDKmemcmp"]
    pub fn FDKmemcmp(
        s1: *const ::std::os::raw::c_void,
        s2: *const ::std::os::raw::c_void,
        size: UINT,
    ) -> INT;
}
extern "C" {
    #[link_name = "\u{1}_FDKstrcmp"]
    pub fn FDKstrcmp(s1: *const ::std::os::raw::c_char, s2: *const ::std::os::raw::c_char) -> INT;
}
extern "C" {
    #[link_name = "\u{1}_FDKstrncmp"]
    pub fn FDKstrncmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        size: UINT,
    ) -> INT;
}
extern "C" {
    #[link_name = "\u{1}_FDKstrlen"]
    pub fn FDKstrlen(s: *const ::std::os::raw::c_char) -> UINT;
}
extern "C" {
    #[doc = "  Check platform for endianess."]
    #[doc = ""]
    #[doc = " \\return  1 if platform is little endian, non-1 if platform is big endian."]
    #[link_name = "\u{1}_IS_LITTLE_ENDIAN"]
    pub fn IS_LITTLE_ENDIAN() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Convert input value to little endian format."]
    #[doc = ""]
    #[doc = " \\param val  Value to be converted. It may be in both big or little endian."]
    #[doc = " \\return     Value in little endian format."]
    #[link_name = "\u{1}_TO_LITTLE_ENDIAN"]
    pub fn TO_LITTLE_ENDIAN(val: UINT) -> UINT;
}
#[doc = " \\fn     FDKFILE *FDKfopen(const char *filename, const char *mode);"]
#[doc = "         Standard fopen() wrapper."]
#[doc = " \\fn     INT FDKfclose(FDKFILE *FP);"]
#[doc = "         Standard fclose() wrapper."]
#[doc = " \\fn     INT FDKfseek(FDKFILE *FP, LONG OFFSET, int WHENCE);"]
#[doc = "         Standard fseek() wrapper."]
#[doc = " \\fn     INT FDKftell(FDKFILE *FP);"]
#[doc = "         Standard ftell() wrapper."]
#[doc = " \\fn     INT FDKfflush(FDKFILE *fp);"]
#[doc = "         Standard fflush() wrapper."]
#[doc = " \\fn     UINT FDKfwrite(const void *ptrf, INT size, UINT nmemb, FDKFILE *fp);"]
#[doc = "         Standard fwrite() wrapper."]
#[doc = " \\fn     UINT FDKfread(void *dst, INT size, UINT nmemb, FDKFILE *fp);"]
#[doc = "         Standard fread() wrapper."]
pub type FDKFILE = ::std::os::raw::c_void;
extern "C" {
    #[link_name = "\u{1}_FDKSEEK_SET"]
    pub static FDKSEEK_SET: INT;
}
extern "C" {
    #[link_name = "\u{1}_FDKSEEK_CUR"]
    pub static FDKSEEK_CUR: INT;
}
extern "C" {
    #[link_name = "\u{1}_FDKSEEK_END"]
    pub static FDKSEEK_END: INT;
}
extern "C" {
    #[link_name = "\u{1}_FDKfopen"]
    pub fn FDKfopen(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FDKFILE;
}
extern "C" {
    #[link_name = "\u{1}_FDKfclose"]
    pub fn FDKfclose(FP: *mut FDKFILE) -> INT;
}
extern "C" {
    #[link_name = "\u{1}_FDKfseek"]
    pub fn FDKfseek(FP: *mut FDKFILE, OFFSET: INT, WHENCE: ::std::os::raw::c_int) -> INT;
}
extern "C" {
    #[link_name = "\u{1}_FDKftell"]
    pub fn FDKftell(FP: *mut FDKFILE) -> INT;
}
extern "C" {
    #[link_name = "\u{1}_FDKfflush"]
    pub fn FDKfflush(fp: *mut FDKFILE) -> INT;
}
extern "C" {
    #[link_name = "\u{1}_FDKfwrite"]
    pub fn FDKfwrite(
        ptrf: *const ::std::os::raw::c_void,
        size: INT,
        nmemb: UINT,
        fp: *mut FDKFILE,
    ) -> UINT;
}
extern "C" {
    #[link_name = "\u{1}_FDKfread"]
    pub fn FDKfread(
        dst: *mut ::std::os::raw::c_void,
        size: INT,
        nmemb: UINT,
        fp: *mut FDKFILE,
    ) -> UINT;
}
extern "C" {
    #[link_name = "\u{1}_FDKfgets"]
    pub fn FDKfgets(
        dst: *mut ::std::os::raw::c_void,
        size: INT,
        fp: *mut FDKFILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_FDKrewind"]
    pub fn FDKrewind(fp: *mut FDKFILE);
}
extern "C" {
    #[link_name = "\u{1}_FDKfeof"]
    pub fn FDKfeof(fp: *mut FDKFILE) -> INT;
}
extern "C" {
    #[doc = " \\brief        Write each member in little endian order. Convert automatically"]
    #[doc = " to host endianess."]
    #[doc = " \\param ptrf   Pointer to memory where to read data from."]
    #[doc = " \\param size   Size of each item to be written."]
    #[doc = " \\param nmemb  Number of items to be written."]
    #[doc = " \\param fp     File pointer of type FDKFILE."]
    #[doc = " \\return       Number of items read on success and fread() error on failure."]
    #[link_name = "\u{1}_FDKfwrite_EL"]
    pub fn FDKfwrite_EL(
        ptrf: *const ::std::os::raw::c_void,
        size: INT,
        nmemb: UINT,
        fp: *mut FDKFILE,
    ) -> UINT;
}
extern "C" {
    #[doc = " \\brief        Read variable of size \"size\" as little endian. Convert"]
    #[doc = " automatically to host endianess. 4-byte alignment is enforced for 24 bit"]
    #[doc = " data, at 32 bit full scale."]
    #[doc = " \\param dst    Pointer to memory where to store data into."]
    #[doc = " \\param size   Size of each item to be read."]
    #[doc = " \\param nmemb  Number of items to be read."]
    #[doc = " \\param fp     File pointer of type FDKFILE."]
    #[doc = " \\return       Number of items read on success and fread() error on failure."]
    #[link_name = "\u{1}_FDKfread_EL"]
    pub fn FDKfread_EL(
        dst: *mut ::std::os::raw::c_void,
        size: INT,
        nmemb: UINT,
        fp: *mut FDKFILE,
    ) -> UINT;
}
extern "C" {
    #[doc = " \\brief  Print FDK software disclaimer."]
    #[link_name = "\u{1}_FDKprintDisclaimer"]
    pub fn FDKprintDisclaimer();
}
#[doc = " \\brief  Contains information needed for a single channel map."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CHANNEL_MAP_INFO {
    #[doc = "< Actual channel mapping for one single configuration."]
    pub pChannelMap: *const UCHAR,
    #[doc = "< The number of channels for the channel map which is"]
    #[doc = "the maximum used channel index+1."]
    pub numChannels: UCHAR,
}
#[test]
fn bindgen_test_layout_CHANNEL_MAP_INFO() {
    assert_eq!(
        ::std::mem::size_of::<CHANNEL_MAP_INFO>(),
        16usize,
        concat!("Size of: ", stringify!(CHANNEL_MAP_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<CHANNEL_MAP_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(CHANNEL_MAP_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CHANNEL_MAP_INFO>())).pChannelMap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CHANNEL_MAP_INFO),
            "::",
            stringify!(pChannelMap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CHANNEL_MAP_INFO>())).numChannels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CHANNEL_MAP_INFO),
            "::",
            stringify!(numChannels)
        )
    );
}
#[doc = " \\brief   This is the main data struct. It contains the mapping for all"]
#[doc = " channel configurations such as administration information."]
#[doc = ""]
#[doc = " CAUTION: Do not access this structure directly from a algorithm specific"]
#[doc = " library. Always use one of the API access functions below!"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FDK_channelMapDescr {
    #[doc = "< Table of channel maps."]
    pub pMapInfoTab: *const CHANNEL_MAP_INFO,
    #[doc = "< Length of the channel map table array."]
    pub mapInfoTabLen: UINT,
    #[doc = "< Flag that defines whether the specified mapping shall"]
    #[doc = "be applied  (value: 0) or the input just gets passed"]
    #[doc = "through (MPEG mapping)."]
    pub fPassThrough: UINT,
}
#[test]
fn bindgen_test_layout_FDK_channelMapDescr() {
    assert_eq!(
        ::std::mem::size_of::<FDK_channelMapDescr>(),
        16usize,
        concat!("Size of: ", stringify!(FDK_channelMapDescr))
    );
    assert_eq!(
        ::std::mem::align_of::<FDK_channelMapDescr>(),
        8usize,
        concat!("Alignment of ", stringify!(FDK_channelMapDescr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDK_channelMapDescr>())).pMapInfoTab as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_channelMapDescr),
            "::",
            stringify!(pMapInfoTab)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDK_channelMapDescr>())).mapInfoTabLen as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_channelMapDescr),
            "::",
            stringify!(mapInfoTabLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FDK_channelMapDescr>())).fPassThrough as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_channelMapDescr),
            "::",
            stringify!(fPassThrough)
        )
    );
}
extern "C" {
    #[doc = " \\brief  Initialize a given channel map descriptor."]
    #[doc = ""]
    #[doc = " \\param  pMapDescr      Pointer to a channel map descriptor to be initialized."]
    #[doc = " \\param  pMapInfoTab    Table of channel maps to initizalize the descriptor"]
    #[doc = "with."]
    #[doc = "                        If a NULL pointer is given a default table for"]
    #[doc = "WAV-like mapping will be used."]
    #[doc = " \\param  mapInfoTabLen  Length of the channel map table array (pMapInfoTab)."]
    #[doc = "If a zero length is given a default table for WAV-like mapping will be used."]
    #[doc = " \\param  fPassThrough   If the flag is set the reordering (given by"]
    #[doc = "pMapInfoTab) will be bypassed."]
    #[link_name = "\u{1}_FDK_chMapDescr_init"]
    pub fn FDK_chMapDescr_init(
        pMapDescr: *mut FDK_channelMapDescr,
        pMapInfoTab: *const CHANNEL_MAP_INFO,
        mapInfoTabLen: UINT,
        fPassThrough: UINT,
    );
}
extern "C" {
    #[doc = " \\brief  Change the channel reordering state of a given channel map"]
    #[doc = " descriptor."]
    #[doc = ""]
    #[doc = " \\param  pMapDescr     Pointer to a (initialized) channel map descriptor."]
    #[doc = " \\param  fPassThrough  If the flag is set the reordering (given by"]
    #[doc = " pMapInfoTab) will be bypassed."]
    #[doc = " \\return               Value unequal to zero if set operation was not"]
    #[doc = " successful. And zero on success."]
    #[link_name = "\u{1}_FDK_chMapDescr_setPassThrough"]
    pub fn FDK_chMapDescr_setPassThrough(
        pMapDescr: *mut FDK_channelMapDescr,
        fPassThrough: UINT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief  Get the mapping value for a specific channel and map index."]
    #[doc = ""]
    #[doc = " \\param  pMapDescr  Pointer to channel map descriptor."]
    #[doc = " \\param  chIdx      Channel index."]
    #[doc = " \\param  mapIdx     Mapping index (corresponding to the channel configuration"]
    #[doc = " index)."]
    #[doc = " \\return            Mapping value."]
    #[link_name = "\u{1}_FDK_chMapDescr_getMapValue"]
    pub fn FDK_chMapDescr_getMapValue(
        pMapDescr: *const FDK_channelMapDescr,
        chIdx: UCHAR,
        mapIdx: UINT,
    ) -> UCHAR;
}
extern "C" {
    #[doc = " \\brief  Evaluate whether channel map descriptor is reasonable or not."]
    #[doc = ""]
    #[doc = " \\param  pMapDescr Pointer to channel map descriptor."]
    #[doc = " \\return           Value unequal to zero if descriptor is valid, otherwise"]
    #[doc = " zero."]
    #[link_name = "\u{1}_FDK_chMapDescr_isValid"]
    pub fn FDK_chMapDescr_isValid(pMapDescr: *const FDK_channelMapDescr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_FDK_mapInfoTabWg4"]
    pub static mut FDK_mapInfoTabWg4: [CHANNEL_MAP_INFO; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_FDK_mapInfoTabLenWg4"]
    pub static FDK_mapInfoTabLenWg4: UINT;
}
#[doc = "< Unknown format."]
pub const FILE_FORMAT_FF_UNKNOWN: FILE_FORMAT = -1;
#[doc = "< No container, bit stream data conveyed \"as is\"."]
pub const FILE_FORMAT_FF_RAW: FILE_FORMAT = 0;
#[doc = "< 3GPP file format."]
pub const FILE_FORMAT_FF_MP4_3GPP: FILE_FORMAT = 3;
#[doc = "< MPEG-4 File format."]
pub const FILE_FORMAT_FF_MP4_MP4F: FILE_FORMAT = 4;
#[doc = "< Proprietary raw packet file."]
pub const FILE_FORMAT_FF_RAWPACKETS: FILE_FORMAT = 5;
#[doc = " File format identifiers."]
pub type FILE_FORMAT = i32;
#[doc = "< Unknown format."]
pub const TRANSPORT_TYPE_TT_UNKNOWN: TRANSPORT_TYPE = -1;
#[doc = "< \"as is\" access units (packet based since there is"]
#[doc = "obviously no sync layer)"]
pub const TRANSPORT_TYPE_TT_MP4_RAW: TRANSPORT_TYPE = 0;
#[doc = "< ADIF bitstream format."]
pub const TRANSPORT_TYPE_TT_MP4_ADIF: TRANSPORT_TYPE = 1;
#[doc = "< ADTS bitstream format."]
pub const TRANSPORT_TYPE_TT_MP4_ADTS: TRANSPORT_TYPE = 2;
#[doc = "< Audio Mux Elements with muxConfigPresent = 1"]
pub const TRANSPORT_TYPE_TT_MP4_LATM_MCP1: TRANSPORT_TYPE = 6;
#[doc = "< Audio Mux Elements with muxConfigPresent = 0, out"]
#[doc = "of band StreamMuxConfig"]
pub const TRANSPORT_TYPE_TT_MP4_LATM_MCP0: TRANSPORT_TYPE = 7;
#[doc = "< Audio Sync Stream."]
pub const TRANSPORT_TYPE_TT_MP4_LOAS: TRANSPORT_TYPE = 10;
#[doc = "< Digital Radio Mondial (DRM30/DRM+) bitstream format."]
pub const TRANSPORT_TYPE_TT_DRM: TRANSPORT_TYPE = 12;
#[doc = " Transport type identifiers."]
pub type TRANSPORT_TYPE = i32;
pub const AUDIO_OBJECT_TYPE_AOT_NONE: AUDIO_OBJECT_TYPE = -1;
pub const AUDIO_OBJECT_TYPE_AOT_NULL_OBJECT: AUDIO_OBJECT_TYPE = 0;
#[doc = "< Main profile"]
pub const AUDIO_OBJECT_TYPE_AOT_AAC_MAIN: AUDIO_OBJECT_TYPE = 1;
#[doc = "< Low Complexity object"]
pub const AUDIO_OBJECT_TYPE_AOT_AAC_LC: AUDIO_OBJECT_TYPE = 2;
pub const AUDIO_OBJECT_TYPE_AOT_AAC_SSR: AUDIO_OBJECT_TYPE = 3;
pub const AUDIO_OBJECT_TYPE_AOT_AAC_LTP: AUDIO_OBJECT_TYPE = 4;
pub const AUDIO_OBJECT_TYPE_AOT_SBR: AUDIO_OBJECT_TYPE = 5;
pub const AUDIO_OBJECT_TYPE_AOT_AAC_SCAL: AUDIO_OBJECT_TYPE = 6;
pub const AUDIO_OBJECT_TYPE_AOT_TWIN_VQ: AUDIO_OBJECT_TYPE = 7;
pub const AUDIO_OBJECT_TYPE_AOT_CELP: AUDIO_OBJECT_TYPE = 8;
pub const AUDIO_OBJECT_TYPE_AOT_HVXC: AUDIO_OBJECT_TYPE = 9;
#[doc = "< (reserved)"]
pub const AUDIO_OBJECT_TYPE_AOT_RSVD_10: AUDIO_OBJECT_TYPE = 10;
#[doc = "< (reserved)"]
pub const AUDIO_OBJECT_TYPE_AOT_RSVD_11: AUDIO_OBJECT_TYPE = 11;
#[doc = "< TTSI Object"]
pub const AUDIO_OBJECT_TYPE_AOT_TTSI: AUDIO_OBJECT_TYPE = 12;
#[doc = "< Main Synthetic object"]
pub const AUDIO_OBJECT_TYPE_AOT_MAIN_SYNTH: AUDIO_OBJECT_TYPE = 13;
#[doc = "< Wavetable Synthesis object"]
pub const AUDIO_OBJECT_TYPE_AOT_WAV_TAB_SYNTH: AUDIO_OBJECT_TYPE = 14;
#[doc = "< General MIDI object"]
pub const AUDIO_OBJECT_TYPE_AOT_GEN_MIDI: AUDIO_OBJECT_TYPE = 15;
#[doc = "< Algorithmic Synthesis and Audio FX object"]
pub const AUDIO_OBJECT_TYPE_AOT_ALG_SYNTH_AUD_FX: AUDIO_OBJECT_TYPE = 16;
#[doc = "< Error Resilient(ER) AAC Low Complexity"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_AAC_LC: AUDIO_OBJECT_TYPE = 17;
#[doc = "< (reserved)"]
pub const AUDIO_OBJECT_TYPE_AOT_RSVD_18: AUDIO_OBJECT_TYPE = 18;
#[doc = "< Error Resilient(ER) AAC LTP object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_AAC_LTP: AUDIO_OBJECT_TYPE = 19;
#[doc = "< Error Resilient(ER) AAC Scalable object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_AAC_SCAL: AUDIO_OBJECT_TYPE = 20;
#[doc = "< Error Resilient(ER) TwinVQ object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_TWIN_VQ: AUDIO_OBJECT_TYPE = 21;
#[doc = "< Error Resilient(ER) BSAC object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_BSAC: AUDIO_OBJECT_TYPE = 22;
#[doc = "< Error Resilient(ER) AAC LowDelay object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_AAC_LD: AUDIO_OBJECT_TYPE = 23;
#[doc = "< Error Resilient(ER) CELP object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_CELP: AUDIO_OBJECT_TYPE = 24;
#[doc = "< Error Resilient(ER) HVXC object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_HVXC: AUDIO_OBJECT_TYPE = 25;
#[doc = "< Error Resilient(ER) HILN object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_HILN: AUDIO_OBJECT_TYPE = 26;
#[doc = "< Error Resilient(ER) Parametric object"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_PARA: AUDIO_OBJECT_TYPE = 27;
#[doc = "< might become SSC"]
pub const AUDIO_OBJECT_TYPE_AOT_RSVD_28: AUDIO_OBJECT_TYPE = 28;
#[doc = "< PS, Parametric Stereo (includes SBR)"]
pub const AUDIO_OBJECT_TYPE_AOT_PS: AUDIO_OBJECT_TYPE = 29;
#[doc = "< MPEG Surround"]
pub const AUDIO_OBJECT_TYPE_AOT_MPEGS: AUDIO_OBJECT_TYPE = 30;
#[doc = "< Signal AOT uses more than 5 bits"]
pub const AUDIO_OBJECT_TYPE_AOT_ESCAPE: AUDIO_OBJECT_TYPE = 31;
#[doc = "< MPEG-Layer1 in mp4"]
pub const AUDIO_OBJECT_TYPE_AOT_MP3ONMP4_L1: AUDIO_OBJECT_TYPE = 32;
#[doc = "< MPEG-Layer2 in mp4"]
pub const AUDIO_OBJECT_TYPE_AOT_MP3ONMP4_L2: AUDIO_OBJECT_TYPE = 33;
#[doc = "< MPEG-Layer3 in mp4"]
pub const AUDIO_OBJECT_TYPE_AOT_MP3ONMP4_L3: AUDIO_OBJECT_TYPE = 34;
#[doc = "< might become DST"]
pub const AUDIO_OBJECT_TYPE_AOT_RSVD_35: AUDIO_OBJECT_TYPE = 35;
#[doc = "< might become ALS"]
pub const AUDIO_OBJECT_TYPE_AOT_RSVD_36: AUDIO_OBJECT_TYPE = 36;
#[doc = "< AAC + SLS"]
pub const AUDIO_OBJECT_TYPE_AOT_AAC_SLS: AUDIO_OBJECT_TYPE = 37;
#[doc = "< SLS"]
pub const AUDIO_OBJECT_TYPE_AOT_SLS: AUDIO_OBJECT_TYPE = 38;
#[doc = "< AAC Enhanced Low Delay"]
pub const AUDIO_OBJECT_TYPE_AOT_ER_AAC_ELD: AUDIO_OBJECT_TYPE = 39;
#[doc = "< USAC"]
pub const AUDIO_OBJECT_TYPE_AOT_USAC: AUDIO_OBJECT_TYPE = 42;
#[doc = "< SAOC"]
pub const AUDIO_OBJECT_TYPE_AOT_SAOC: AUDIO_OBJECT_TYPE = 43;
#[doc = "< Low Delay MPEG Surround"]
pub const AUDIO_OBJECT_TYPE_AOT_LD_MPEGS: AUDIO_OBJECT_TYPE = 44;
#[doc = "< Virtual AOT MP2 Low Complexity profile"]
pub const AUDIO_OBJECT_TYPE_AOT_MP2_AAC_LC: AUDIO_OBJECT_TYPE = 129;
#[doc = "< Virtual AOT MP2 Low Complexity Profile with SBR"]
pub const AUDIO_OBJECT_TYPE_AOT_MP2_SBR: AUDIO_OBJECT_TYPE = 132;
#[doc = "< Virtual AOT for DRM (ER-AAC-SCAL without SBR)"]
pub const AUDIO_OBJECT_TYPE_AOT_DRM_AAC: AUDIO_OBJECT_TYPE = 143;
#[doc = "< Virtual AOT for DRM (ER-AAC-SCAL with SBR)"]
pub const AUDIO_OBJECT_TYPE_AOT_DRM_SBR: AUDIO_OBJECT_TYPE = 144;
pub const AUDIO_OBJECT_TYPE_AOT_DRM_MPEG_PS: AUDIO_OBJECT_TYPE = 145;
pub const AUDIO_OBJECT_TYPE_AOT_DRM_SURROUND: AUDIO_OBJECT_TYPE = 146;
#[doc = "< Virtual AOT for DRM with USAC"]
pub const AUDIO_OBJECT_TYPE_AOT_DRM_USAC: AUDIO_OBJECT_TYPE = 147;
#[doc = " Audio Object Type definitions."]
pub type AUDIO_OBJECT_TYPE = i32;
pub const CHANNEL_MODE_MODE_INVALID: CHANNEL_MODE = -1;
pub const CHANNEL_MODE_MODE_UNKNOWN: CHANNEL_MODE = 0;
#[doc = "< C"]
pub const CHANNEL_MODE_MODE_1: CHANNEL_MODE = 1;
#[doc = "< L+R"]
pub const CHANNEL_MODE_MODE_2: CHANNEL_MODE = 2;
#[doc = "< C, L+R"]
pub const CHANNEL_MODE_MODE_1_2: CHANNEL_MODE = 3;
#[doc = "< C, L+R, Rear"]
pub const CHANNEL_MODE_MODE_1_2_1: CHANNEL_MODE = 4;
#[doc = "< C, L+R, LS+RS"]
pub const CHANNEL_MODE_MODE_1_2_2: CHANNEL_MODE = 5;
#[doc = "< C, L+R, LS+RS, LFE"]
pub const CHANNEL_MODE_MODE_1_2_2_1: CHANNEL_MODE = 6;
#[doc = "< C, LC+RC, L+R, LS+RS, LFE"]
pub const CHANNEL_MODE_MODE_1_2_2_2_1: CHANNEL_MODE = 7;
#[doc = "< C, L+R, LS+RS, Crear, LFE"]
pub const CHANNEL_MODE_MODE_6_1: CHANNEL_MODE = 11;
#[doc = "< C, L+R, LS+RS, Lrear+Rrear, LFE"]
pub const CHANNEL_MODE_MODE_7_1_BACK: CHANNEL_MODE = 12;
#[doc = "< C, L+R, LS+RS, LFE, Ltop+Rtop"]
pub const CHANNEL_MODE_MODE_7_1_TOP_FRONT: CHANNEL_MODE = 14;
#[doc = "< C, L+R, LS+RS, Lrear+Rrear, LFE"]
pub const CHANNEL_MODE_MODE_7_1_REAR_SURROUND: CHANNEL_MODE = 33;
#[doc = "< C, LC+RC, L+R, LS+RS, LFE"]
pub const CHANNEL_MODE_MODE_7_1_FRONT_CENTER: CHANNEL_MODE = 34;
#[doc = "< 212 configuration, used in ELDv2"]
pub const CHANNEL_MODE_MODE_212: CHANNEL_MODE = 128;
#[doc = " Channel Mode ( 1-7 equals MPEG channel configurations, others are"]
#[doc = " arbitrary)."]
pub type CHANNEL_MODE = i32;
pub const AUDIO_CHANNEL_TYPE_ACT_NONE: AUDIO_CHANNEL_TYPE = 0;
#[doc = "< Front speaker position (at normal height)"]
pub const AUDIO_CHANNEL_TYPE_ACT_FRONT: AUDIO_CHANNEL_TYPE = 1;
#[doc = "< Side speaker position (at normal height)"]
pub const AUDIO_CHANNEL_TYPE_ACT_SIDE: AUDIO_CHANNEL_TYPE = 2;
#[doc = "< Back speaker position (at normal height)"]
pub const AUDIO_CHANNEL_TYPE_ACT_BACK: AUDIO_CHANNEL_TYPE = 3;
#[doc = "< Low frequency effect speaker postion (front)"]
pub const AUDIO_CHANNEL_TYPE_ACT_LFE: AUDIO_CHANNEL_TYPE = 4;
pub const AUDIO_CHANNEL_TYPE_ACT_TOP: AUDIO_CHANNEL_TYPE = 16;
#[doc = "< Top front speaker = (ACT_FRONT|ACT_TOP)"]
pub const AUDIO_CHANNEL_TYPE_ACT_FRONT_TOP: AUDIO_CHANNEL_TYPE = 17;
#[doc = "< Top side speaker  = (ACT_SIDE |ACT_TOP)"]
pub const AUDIO_CHANNEL_TYPE_ACT_SIDE_TOP: AUDIO_CHANNEL_TYPE = 18;
#[doc = "< Top back speaker  = (ACT_BACK |ACT_TOP)"]
pub const AUDIO_CHANNEL_TYPE_ACT_BACK_TOP: AUDIO_CHANNEL_TYPE = 19;
pub const AUDIO_CHANNEL_TYPE_ACT_BOTTOM: AUDIO_CHANNEL_TYPE = 32;
#[doc = "< Bottom front speaker = (ACT_FRONT|ACT_BOTTOM)"]
pub const AUDIO_CHANNEL_TYPE_ACT_FRONT_BOTTOM: AUDIO_CHANNEL_TYPE = 33;
#[doc = "< Bottom side speaker  = (ACT_SIDE |ACT_BOTTOM)"]
pub const AUDIO_CHANNEL_TYPE_ACT_SIDE_BOTTOM: AUDIO_CHANNEL_TYPE = 34;
#[doc = "< Bottom back speaker  = (ACT_BACK |ACT_BOTTOM)"]
pub const AUDIO_CHANNEL_TYPE_ACT_BACK_BOTTOM: AUDIO_CHANNEL_TYPE = 35;
#[doc = " Speaker description tags."]
#[doc = " Do not change the enumeration values unless it keeps the following"]
#[doc = " segmentation:"]
#[doc = " - Bit 0-3: Horizontal postion (0: none, 1: front, 2: side, 3: back, 4: lfe)"]
#[doc = " - Bit 4-7: Vertical position (0: normal, 1: top, 2: bottom)"]
pub type AUDIO_CHANNEL_TYPE = u32;
pub const SBR_PS_SIGNALING_SIG_UNKNOWN: SBR_PS_SIGNALING = -1;
pub const SBR_PS_SIGNALING_SIG_IMPLICIT: SBR_PS_SIGNALING = 0;
pub const SBR_PS_SIGNALING_SIG_EXPLICIT_BW_COMPATIBLE: SBR_PS_SIGNALING = 1;
pub const SBR_PS_SIGNALING_SIG_EXPLICIT_HIERARCHICAL: SBR_PS_SIGNALING = 2;
pub type SBR_PS_SIGNALING = i32;
#[doc = " Generic audio coder configuration structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CODER_CONFIG {
    #[doc = "< Audio Object Type (AOT)."]
    pub aot: AUDIO_OBJECT_TYPE,
    #[doc = "< Extension Audio Object Type (SBR)."]
    pub extAOT: AUDIO_OBJECT_TYPE,
    #[doc = "< Channel mode."]
    pub channelMode: CHANNEL_MODE,
    #[doc = "< Use channel config zero + pce although a"]
    #[doc = "standard channel config could be signaled."]
    pub channelConfigZero: UCHAR,
    #[doc = "< Sampling rate."]
    pub samplingRate: INT,
    #[doc = "< Extended samplerate (SBR)."]
    pub extSamplingRate: INT,
    #[doc = "< Downscale sampling rate (ELD downscaled mode)"]
    pub downscaleSamplingRate: INT,
    #[doc = "< Average bitrate."]
    pub bitRate: INT,
    #[doc = "< Number of PCM samples per codec frame and audio"]
    #[doc = "channel."]
    pub samplesPerFrame: ::std::os::raw::c_int,
    #[doc = "< Number of audio channels."]
    pub noChannels: ::std::os::raw::c_int,
    pub bitsFrame: ::std::os::raw::c_int,
    #[doc = "< Amount of encoder subframes. 1 means no subframing."]
    pub nSubFrames: ::std::os::raw::c_int,
    #[doc = "< The number of the sub-frames which are grouped and"]
    #[doc = "transmitted in a super-frame (BSAC)."]
    pub BSACnumOfSubFrame: ::std::os::raw::c_int,
    #[doc = "< The average length of the large-step layers in bytes"]
    #[doc = "(BSAC)."]
    pub BSAClayerLength: ::std::os::raw::c_int,
    #[doc = "< flags"]
    pub flags: UINT,
    #[doc = "< Matrix mixdown index to put into PCE. Default value"]
    #[doc = "0 means no mixdown coefficient, valid values are 1-4"]
    #[doc = "which correspond to matrix_mixdown_idx 0-3."]
    pub matrixMixdownA: UCHAR,
    #[doc = "< Frame period for sending in band configuration"]
    #[doc = "buffers in the transport layer."]
    pub headerPeriod: UCHAR,
    #[doc = "< USAC MPS stereo mode"]
    pub stereoConfigIndex: UCHAR,
    #[doc = "< USAC SBR mode"]
    pub sbrMode: UCHAR,
    #[doc = "< 0: implicit signaling, 1: backwards"]
    #[doc = "compatible explicit signaling, 2:"]
    #[doc = "hierarcical explicit signaling"]
    pub sbrSignaling: SBR_PS_SIGNALING,
    #[doc = "< raw codec specific config as bit stream"]
    pub rawConfig: [UCHAR; 64usize],
    #[doc = "< Size of rawConfig in bits"]
    pub rawConfigBits: ::std::os::raw::c_int,
    pub sbrPresent: UCHAR,
    pub psPresent: UCHAR,
}
#[test]
fn bindgen_test_layout_CODER_CONFIG() {
    assert_eq!(
        ::std::mem::size_of::<CODER_CONFIG>(),
        140usize,
        concat!("Size of: ", stringify!(CODER_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<CODER_CONFIG>(),
        4usize,
        concat!("Alignment of ", stringify!(CODER_CONFIG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).aot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(aot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).extAOT as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(extAOT)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).channelMode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(channelMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).channelConfigZero as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(channelConfigZero)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).samplingRate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(samplingRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).extSamplingRate as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(extSamplingRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CODER_CONFIG>())).downscaleSamplingRate as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(downscaleSamplingRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).bitRate as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(bitRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).samplesPerFrame as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(samplesPerFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).noChannels as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(noChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).bitsFrame as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(bitsFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).nSubFrames as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(nSubFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).BSACnumOfSubFrame as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(BSACnumOfSubFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).BSAClayerLength as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(BSAClayerLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).matrixMixdownA as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(matrixMixdownA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).headerPeriod as *const _ as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(headerPeriod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).stereoConfigIndex as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(stereoConfigIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).sbrMode as *const _ as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(sbrMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).sbrSignaling as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(sbrSignaling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).rawConfig as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(rawConfig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).rawConfigBits as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(rawConfigBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).sbrPresent as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(sbrPresent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CODER_CONFIG>())).psPresent as *const _ as usize },
        137usize,
        concat!(
            "Offset of field: ",
            stringify!(CODER_CONFIG),
            "::",
            stringify!(psPresent)
        )
    );
}
#[doc = "< Invalid Element helper ID."]
pub const MP4_ELEMENT_ID_ID_NONE: MP4_ELEMENT_ID = -1;
#[doc = "< Single Channel Element."]
pub const MP4_ELEMENT_ID_ID_SCE: MP4_ELEMENT_ID = 0;
#[doc = "< Channel Pair Element."]
pub const MP4_ELEMENT_ID_ID_CPE: MP4_ELEMENT_ID = 1;
#[doc = "< Coupling Channel Element."]
pub const MP4_ELEMENT_ID_ID_CCE: MP4_ELEMENT_ID = 2;
#[doc = "< LFE Channel Element."]
pub const MP4_ELEMENT_ID_ID_LFE: MP4_ELEMENT_ID = 3;
#[doc = "< Currently one Data Stream Element for ancillary data is"]
#[doc = "supported."]
pub const MP4_ELEMENT_ID_ID_DSE: MP4_ELEMENT_ID = 4;
#[doc = "< Program Config Element."]
pub const MP4_ELEMENT_ID_ID_PCE: MP4_ELEMENT_ID = 5;
#[doc = "< Fill Element."]
pub const MP4_ELEMENT_ID_ID_FIL: MP4_ELEMENT_ID = 6;
#[doc = "< Arnie (End Element = Terminator)."]
pub const MP4_ELEMENT_ID_ID_END: MP4_ELEMENT_ID = 7;
#[doc = "< Extension Payload (ER only)."]
pub const MP4_ELEMENT_ID_ID_EXT: MP4_ELEMENT_ID = 8;
#[doc = "< AAC scalable element (ER only)."]
pub const MP4_ELEMENT_ID_ID_SCAL: MP4_ELEMENT_ID = 9;
#[doc = "< Single Channel Element."]
pub const MP4_ELEMENT_ID_ID_USAC_SCE: MP4_ELEMENT_ID = 16;
#[doc = "< Channel Pair Element."]
pub const MP4_ELEMENT_ID_ID_USAC_CPE: MP4_ELEMENT_ID = 17;
#[doc = "< LFE Channel Element."]
pub const MP4_ELEMENT_ID_ID_USAC_LFE: MP4_ELEMENT_ID = 18;
#[doc = "< Extension Element."]
pub const MP4_ELEMENT_ID_ID_USAC_EXT: MP4_ELEMENT_ID = 19;
#[doc = "< Arnie (End Element = Terminator)."]
pub const MP4_ELEMENT_ID_ID_USAC_END: MP4_ELEMENT_ID = 20;
pub const MP4_ELEMENT_ID_ID_LAST: MP4_ELEMENT_ID = 21;
#[doc = " MP4 Element IDs."]
pub type MP4_ELEMENT_ID = i32;
pub const CONFIG_EXT_ID_ID_CONFIG_EXT_FILL: CONFIG_EXT_ID = 0;
pub const CONFIG_EXT_ID_ID_CONFIG_EXT_DOWNMIX: CONFIG_EXT_ID = 1;
pub const CONFIG_EXT_ID_ID_CONFIG_EXT_LOUDNESS_INFO: CONFIG_EXT_ID = 2;
pub const CONFIG_EXT_ID_ID_CONFIG_EXT_AUDIOSCENE_INFO: CONFIG_EXT_ID = 3;
pub const CONFIG_EXT_ID_ID_CONFIG_EXT_HOA_MATRIX: CONFIG_EXT_ID = 4;
pub const CONFIG_EXT_ID_ID_CONFIG_EXT_SIG_GROUP_INFO: CONFIG_EXT_ID = 6;
pub type CONFIG_EXT_ID = u32;
pub const EXT_PAYLOAD_TYPE_EXT_FIL: EXT_PAYLOAD_TYPE = 0;
pub const EXT_PAYLOAD_TYPE_EXT_FILL_DATA: EXT_PAYLOAD_TYPE = 1;
pub const EXT_PAYLOAD_TYPE_EXT_DATA_ELEMENT: EXT_PAYLOAD_TYPE = 2;
pub const EXT_PAYLOAD_TYPE_EXT_DATA_LENGTH: EXT_PAYLOAD_TYPE = 3;
pub const EXT_PAYLOAD_TYPE_EXT_UNI_DRC: EXT_PAYLOAD_TYPE = 4;
pub const EXT_PAYLOAD_TYPE_EXT_LDSAC_DATA: EXT_PAYLOAD_TYPE = 9;
pub const EXT_PAYLOAD_TYPE_EXT_SAOC_DATA: EXT_PAYLOAD_TYPE = 10;
pub const EXT_PAYLOAD_TYPE_EXT_DYNAMIC_RANGE: EXT_PAYLOAD_TYPE = 11;
pub const EXT_PAYLOAD_TYPE_EXT_SAC_DATA: EXT_PAYLOAD_TYPE = 12;
pub const EXT_PAYLOAD_TYPE_EXT_SBR_DATA: EXT_PAYLOAD_TYPE = 13;
pub const EXT_PAYLOAD_TYPE_EXT_SBR_DATA_CRC: EXT_PAYLOAD_TYPE = 14;
#[doc = " Extension payload types."]
pub type EXT_PAYLOAD_TYPE = u32;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_FILL: USAC_EXT_ELEMENT_TYPE = 0;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_MPEGS: USAC_EXT_ELEMENT_TYPE = 1;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_SAOC: USAC_EXT_ELEMENT_TYPE = 2;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_AUDIOPREROLL: USAC_EXT_ELEMENT_TYPE = 3;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_UNI_DRC: USAC_EXT_ELEMENT_TYPE = 4;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_OBJ_METADATA: USAC_EXT_ELEMENT_TYPE = 5;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_SAOC_3D: USAC_EXT_ELEMENT_TYPE = 6;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_HOA: USAC_EXT_ELEMENT_TYPE = 7;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_FMT_CNVRTR: USAC_EXT_ELEMENT_TYPE = 8;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_MCT: USAC_EXT_ELEMENT_TYPE = 9;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_ENHANCED_OBJ_METADATA: USAC_EXT_ELEMENT_TYPE = 13;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_VR_METADATA: USAC_EXT_ELEMENT_TYPE = 129;
pub const USAC_EXT_ELEMENT_TYPE_ID_EXT_ELE_UNKNOWN: USAC_EXT_ELEMENT_TYPE = 255;
#[doc = " MPEG-D USAC & RSVD60 3D audio Extension Element Types."]
pub type USAC_EXT_ELEMENT_TYPE = u32;
pub const TP_CONFIG_TYPE_TC_NOTHING: TP_CONFIG_TYPE = 0;
pub const TP_CONFIG_TYPE_TC_RAW_ADTS: TP_CONFIG_TYPE = 2;
pub const TP_CONFIG_TYPE_TC_RAW_LATM_MCP1: TP_CONFIG_TYPE = 6;
pub const TP_CONFIG_TYPE_TC_RAW_SDC: TP_CONFIG_TYPE = 21;
#[doc = " Proprietary raw packet file configuration data type identifier."]
pub type TP_CONFIG_TYPE = u32;
pub const FDK_MODULE_ID_FDK_NONE: FDK_MODULE_ID = 0;
pub const FDK_MODULE_ID_FDK_TOOLS: FDK_MODULE_ID = 1;
pub const FDK_MODULE_ID_FDK_SYSLIB: FDK_MODULE_ID = 2;
pub const FDK_MODULE_ID_FDK_AACDEC: FDK_MODULE_ID = 3;
pub const FDK_MODULE_ID_FDK_AACENC: FDK_MODULE_ID = 4;
pub const FDK_MODULE_ID_FDK_SBRDEC: FDK_MODULE_ID = 5;
pub const FDK_MODULE_ID_FDK_SBRENC: FDK_MODULE_ID = 6;
pub const FDK_MODULE_ID_FDK_TPDEC: FDK_MODULE_ID = 7;
pub const FDK_MODULE_ID_FDK_TPENC: FDK_MODULE_ID = 8;
pub const FDK_MODULE_ID_FDK_MPSDEC: FDK_MODULE_ID = 9;
pub const FDK_MODULE_ID_FDK_MPEGFILEREAD: FDK_MODULE_ID = 10;
pub const FDK_MODULE_ID_FDK_MPEGFILEWRITE: FDK_MODULE_ID = 11;
pub const FDK_MODULE_ID_FDK_PCMDMX: FDK_MODULE_ID = 31;
pub const FDK_MODULE_ID_FDK_MPSENC: FDK_MODULE_ID = 34;
pub const FDK_MODULE_ID_FDK_TDLIMIT: FDK_MODULE_ID = 35;
pub const FDK_MODULE_ID_FDK_UNIDRCDEC: FDK_MODULE_ID = 38;
pub const FDK_MODULE_ID_FDK_MODULE_LAST: FDK_MODULE_ID = 39;
pub type FDK_MODULE_ID = u32;
#[doc = "  Library information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIB_INFO {
    pub title: *const ::std::os::raw::c_char,
    pub build_date: *const ::std::os::raw::c_char,
    pub build_time: *const ::std::os::raw::c_char,
    pub module_id: FDK_MODULE_ID,
    pub version: INT,
    pub flags: UINT,
    pub versionStr: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_LIB_INFO() {
    assert_eq!(
        ::std::mem::size_of::<LIB_INFO>(),
        72usize,
        concat!("Size of: ", stringify!(LIB_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<LIB_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(LIB_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIB_INFO>())).title as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIB_INFO),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIB_INFO>())).build_date as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIB_INFO),
            "::",
            stringify!(build_date)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIB_INFO>())).build_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LIB_INFO),
            "::",
            stringify!(build_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIB_INFO>())).module_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LIB_INFO),
            "::",
            stringify!(module_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIB_INFO>())).version as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LIB_INFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIB_INFO>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LIB_INFO),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIB_INFO>())).versionStr as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(LIB_INFO),
            "::",
            stringify!(versionStr)
        )
    );
}
#[doc = "  I/O buffer descriptor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FDK_bufDescr {
    #[doc = "< Pointer to an array containing buffer base addresses."]
    #[doc = "Set to NULL for buffer requirement info."]
    pub ppBase: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Pointer to an array containing the number of elements"]
    #[doc = "that can be placed in the specific buffer."]
    pub pBufSize: *mut UINT,
    #[doc = "< Pointer to an array containing the element size for each"]
    #[doc = "buffer in bytes. That is mostly the number returned by the"]
    #[doc = "sizeof() operator for the data type used for the specific"]
    #[doc = "buffer."]
    pub pEleSize: *mut UINT,
    #[doc = "< Pointer to an array of bit fields containing a description"]
    #[doc = "for each buffer. See XXX below for more details."]
    pub pBufType: *mut UINT,
    #[doc = "< Total number of buffers."]
    pub numBufs: UINT,
}
#[test]
fn bindgen_test_layout_FDK_bufDescr() {
    assert_eq!(
        ::std::mem::size_of::<FDK_bufDescr>(),
        40usize,
        concat!("Size of: ", stringify!(FDK_bufDescr))
    );
    assert_eq!(
        ::std::mem::align_of::<FDK_bufDescr>(),
        8usize,
        concat!("Alignment of ", stringify!(FDK_bufDescr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDK_bufDescr>())).ppBase as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_bufDescr),
            "::",
            stringify!(ppBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDK_bufDescr>())).pBufSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_bufDescr),
            "::",
            stringify!(pBufSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDK_bufDescr>())).pEleSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_bufDescr),
            "::",
            stringify!(pEleSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDK_bufDescr>())).pBufType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_bufDescr),
            "::",
            stringify!(pBufType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FDK_bufDescr>())).numBufs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FDK_bufDescr),
            "::",
            stringify!(numBufs)
        )
    );
}
#[doc = "< No error happened. All fine."]
pub const AACENC_ERROR_AACENC_OK: AACENC_ERROR = 0;
pub const AACENC_ERROR_AACENC_INVALID_HANDLE: AACENC_ERROR = 32;
#[doc = "< Memory allocation failed."]
pub const AACENC_ERROR_AACENC_MEMORY_ERROR: AACENC_ERROR = 33;
#[doc = "< Parameter not available."]
pub const AACENC_ERROR_AACENC_UNSUPPORTED_PARAMETER: AACENC_ERROR = 34;
#[doc = "< Configuration not provided."]
pub const AACENC_ERROR_AACENC_INVALID_CONFIG: AACENC_ERROR = 35;
#[doc = "< General initialization error."]
pub const AACENC_ERROR_AACENC_INIT_ERROR: AACENC_ERROR = 64;
#[doc = "< AAC library initialization error."]
pub const AACENC_ERROR_AACENC_INIT_AAC_ERROR: AACENC_ERROR = 65;
#[doc = "< SBR library initialization error."]
pub const AACENC_ERROR_AACENC_INIT_SBR_ERROR: AACENC_ERROR = 66;
#[doc = "< Transport library initialization error."]
pub const AACENC_ERROR_AACENC_INIT_TP_ERROR: AACENC_ERROR = 67;
pub const AACENC_ERROR_AACENC_INIT_META_ERROR: AACENC_ERROR = 68;
#[doc = "< MPS library initialization error."]
pub const AACENC_ERROR_AACENC_INIT_MPS_ERROR: AACENC_ERROR = 69;
#[doc = "< The encoding process was interrupted by an"]
#[doc = "unexpected error."]
pub const AACENC_ERROR_AACENC_ENCODE_ERROR: AACENC_ERROR = 96;
#[doc = "< End of file reached."]
pub const AACENC_ERROR_AACENC_ENCODE_EOF: AACENC_ERROR = 128;
#[doc = "  AAC encoder error codes."]
pub type AACENC_ERROR = u32;
#[doc = "< Audio input buffer, interleaved INT_PCM samples."]
pub const AACENC_BufferIdentifier_IN_AUDIO_DATA: AACENC_BufferIdentifier = 0;
#[doc = "< Ancillary data to be embedded into bitstream."]
pub const AACENC_BufferIdentifier_IN_ANCILLRY_DATA: AACENC_BufferIdentifier = 1;
#[doc = "< Setup structure for embedding meta data."]
pub const AACENC_BufferIdentifier_IN_METADATA_SETUP: AACENC_BufferIdentifier = 2;
#[doc = "< Buffer holds bitstream output data."]
pub const AACENC_BufferIdentifier_OUT_BITSTREAM_DATA: AACENC_BufferIdentifier = 3;
pub const AACENC_BufferIdentifier_OUT_AU_SIZES: AACENC_BufferIdentifier = 4;
#[doc = "  AAC encoder buffer descriptors identifier."]
#[doc = "  This identifier are used within buffer descriptors"]
#[doc = " AACENC_BufDesc::bufferIdentifiers."]
pub type AACENC_BufferIdentifier = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AACENCODER {
    _unused: [u8; 0],
}
#[doc = "  AAC encoder handle."]
pub type HANDLE_AACENCODER = *mut AACENCODER;
#[doc = "  Provides some info about the encoder configuration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AACENC_InfoStruct {
    #[doc = "< Maximum number of encoder bitstream bytes within one"]
    #[doc = "frame. Size depends on maximum number of supported"]
    #[doc = "channels in encoder instance. For superframing (as"]
    #[doc = "used for example in DAB+), size has to be a multiple"]
    #[doc = "accordingly."]
    pub maxOutBufBytes: UINT,
    #[doc = "< Maximum number of ancillary data bytes which can be"]
    #[doc = "inserted into bitstream within one frame."]
    pub maxAncBytes: UINT,
    #[doc = "< Internal input buffer fill level in samples per"]
    #[doc = "channel. This parameter will automatically be cleared"]
    #[doc = "if samplingrate or channel(Mode/Order) changes."]
    pub inBufFillLevel: UINT,
    #[doc = "< Number of input channels expected in encoding"]
    #[doc = "process."]
    pub inputChannels: UINT,
    #[doc = "< Amount of input audio samples consumed each frame per"]
    #[doc = "channel, depending on audio object type configuration."]
    pub frameLength: UINT,
    #[doc = "< Codec delay in PCM samples/channel. Depends on framelength"]
    #[doc = "and AOT. Does not include framing delay for filling up encoder"]
    #[doc = "PCM input buffer."]
    pub nDelay: UINT,
    #[doc = "< Codec delay in PCM samples/channel, w/o delay caused by"]
    #[doc = "the decoder SBR module. This delay is needed to correctly"]
    #[doc = "write edit lists for gapless playback. The decoder may not"]
    #[doc = "know how much delay is introdcued by SBR, since it may not"]
    #[doc = "know if SBR is active at all (implicit signaling),"]
    #[doc = "therefore the deocder must take into account any delay"]
    #[doc = "caused by the SBR module."]
    pub nDelayCore: UINT,
    #[doc = "< Configuration buffer in binary format as an"]
    #[doc = "AudioSpecificConfig or StreamMuxConfig according to the"]
    #[doc = "selected transport type."]
    pub confBuf: [UCHAR; 64usize],
    #[doc = "< Number of valid bytes in confBuf."]
    pub confSize: UINT,
}
#[test]
fn bindgen_test_layout_AACENC_InfoStruct() {
    assert_eq!(
        ::std::mem::size_of::<AACENC_InfoStruct>(),
        96usize,
        concat!("Size of: ", stringify!(AACENC_InfoStruct))
    );
    assert_eq!(
        ::std::mem::align_of::<AACENC_InfoStruct>(),
        4usize,
        concat!("Alignment of ", stringify!(AACENC_InfoStruct))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_InfoStruct>())).maxOutBufBytes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(maxOutBufBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InfoStruct>())).maxAncBytes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(maxAncBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_InfoStruct>())).inBufFillLevel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(inBufFillLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InfoStruct>())).inputChannels as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(inputChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InfoStruct>())).frameLength as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(frameLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InfoStruct>())).nDelay as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(nDelay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InfoStruct>())).nDelayCore as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(nDelayCore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InfoStruct>())).confBuf as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(confBuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InfoStruct>())).confSize as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InfoStruct),
            "::",
            stringify!(confSize)
        )
    );
}
#[doc = "  Describes the input and output buffers for an aacEncEncode() call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AACENC_BufDesc {
    #[doc = "< Number of buffers."]
    pub numBufs: INT,
    #[doc = "< Pointer to vector containing buffer addresses."]
    pub bufs: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Identifier of each buffer element. See"]
    #[doc = "::AACENC_BufferIdentifier."]
    pub bufferIdentifiers: *mut INT,
    #[doc = "< Size of each buffer in 8-bit bytes."]
    pub bufSizes: *mut INT,
    #[doc = "< Size of each buffer element in bytes."]
    pub bufElSizes: *mut INT,
}
#[test]
fn bindgen_test_layout_AACENC_BufDesc() {
    assert_eq!(
        ::std::mem::size_of::<AACENC_BufDesc>(),
        40usize,
        concat!("Size of: ", stringify!(AACENC_BufDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<AACENC_BufDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(AACENC_BufDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_BufDesc>())).numBufs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_BufDesc),
            "::",
            stringify!(numBufs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_BufDesc>())).bufs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_BufDesc),
            "::",
            stringify!(bufs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_BufDesc>())).bufferIdentifiers as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_BufDesc),
            "::",
            stringify!(bufferIdentifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_BufDesc>())).bufSizes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_BufDesc),
            "::",
            stringify!(bufSizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_BufDesc>())).bufElSizes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_BufDesc),
            "::",
            stringify!(bufElSizes)
        )
    );
}
#[doc = "  Defines the input arguments for an aacEncEncode() call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AACENC_InArgs {
    #[doc = "< Number of valid input audio samples (multiple of input"]
    #[doc = "channels)."]
    pub numInSamples: INT,
    #[doc = "< Number of ancillary data bytes to be encoded."]
    pub numAncBytes: INT,
}
#[test]
fn bindgen_test_layout_AACENC_InArgs() {
    assert_eq!(
        ::std::mem::size_of::<AACENC_InArgs>(),
        8usize,
        concat!("Size of: ", stringify!(AACENC_InArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<AACENC_InArgs>(),
        4usize,
        concat!("Alignment of ", stringify!(AACENC_InArgs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InArgs>())).numInSamples as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InArgs),
            "::",
            stringify!(numInSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_InArgs>())).numAncBytes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_InArgs),
            "::",
            stringify!(numAncBytes)
        )
    );
}
#[doc = "  Defines the output arguments for an aacEncEncode() call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AACENC_OutArgs {
    #[doc = "< Number of valid bitstream bytes generated during"]
    #[doc = "aacEncEncode()."]
    pub numOutBytes: INT,
    #[doc = "< Number of input audio samples consumed by the encoder."]
    pub numInSamples: INT,
    #[doc = "< Number of ancillary data bytes consumed by the encoder."]
    pub numAncBytes: INT,
    #[doc = "< State of the bit reservoir in bits."]
    pub bitResState: INT,
}
#[test]
fn bindgen_test_layout_AACENC_OutArgs() {
    assert_eq!(
        ::std::mem::size_of::<AACENC_OutArgs>(),
        16usize,
        concat!("Size of: ", stringify!(AACENC_OutArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<AACENC_OutArgs>(),
        4usize,
        concat!("Alignment of ", stringify!(AACENC_OutArgs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_OutArgs>())).numOutBytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_OutArgs),
            "::",
            stringify!(numOutBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_OutArgs>())).numInSamples as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_OutArgs),
            "::",
            stringify!(numInSamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_OutArgs>())).numAncBytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_OutArgs),
            "::",
            stringify!(numAncBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_OutArgs>())).bitResState as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_OutArgs),
            "::",
            stringify!(bitResState)
        )
    );
}
#[doc = "< None."]
pub const AACENC_METADATA_DRC_PROFILE_AACENC_METADATA_DRC_NONE: AACENC_METADATA_DRC_PROFILE = 0;
#[doc = "< Film standard."]
pub const AACENC_METADATA_DRC_PROFILE_AACENC_METADATA_DRC_FILMSTANDARD:
    AACENC_METADATA_DRC_PROFILE = 1;
#[doc = "< Film light."]
pub const AACENC_METADATA_DRC_PROFILE_AACENC_METADATA_DRC_FILMLIGHT: AACENC_METADATA_DRC_PROFILE =
    2;
#[doc = "< Music standard."]
pub const AACENC_METADATA_DRC_PROFILE_AACENC_METADATA_DRC_MUSICSTANDARD:
    AACENC_METADATA_DRC_PROFILE = 3;
#[doc = "< Music light."]
pub const AACENC_METADATA_DRC_PROFILE_AACENC_METADATA_DRC_MUSICLIGHT: AACENC_METADATA_DRC_PROFILE =
    4;
#[doc = "< Speech."]
pub const AACENC_METADATA_DRC_PROFILE_AACENC_METADATA_DRC_SPEECH: AACENC_METADATA_DRC_PROFILE = 5;
pub const AACENC_METADATA_DRC_PROFILE_AACENC_METADATA_DRC_NOT_PRESENT: AACENC_METADATA_DRC_PROFILE =
    256;
#[doc = "  Meta Data Compression Profiles."]
pub type AACENC_METADATA_DRC_PROFILE = u32;
#[doc = "  Meta Data setup structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AACENC_MetaData {
    #[doc = "< MPEG DRC compression profile. See"]
    #[doc = "::AACENC_METADATA_DRC_PROFILE."]
    pub drc_profile: AACENC_METADATA_DRC_PROFILE,
    #[doc = "< ETSI heavy compression profile. See"]
    #[doc = "::AACENC_METADATA_DRC_PROFILE."]
    pub comp_profile: AACENC_METADATA_DRC_PROFILE,
    #[doc = "< Used to define expected level to:"]
    #[doc = "Scaled with 16 bit. x*2^16."]
    pub drc_TargetRefLevel: INT,
    #[doc = "< Adjust limiter to avoid overload."]
    #[doc = "Scaled with 16 bit. x*2^16."]
    pub comp_TargetRefLevel: INT,
    #[doc = "< Flag, if prog_ref_level is present"]
    pub prog_ref_level_present: INT,
    #[doc = "< Programme Reference Level = Dialogue Level:"]
    #[doc = "-31.75dB .. 0 dB ; stepsize: 0.25dB"]
    #[doc = "Scaled with 16 bit. x*2^16."]
    pub prog_ref_level: INT,
    #[doc = "< Flag, if dmx-idx should be written in"]
    #[doc = "programme config element"]
    pub PCE_mixdown_idx_present: UCHAR,
    #[doc = "< Flag, if dmx-lvl should be written in"]
    #[doc = "ETSI-ancData"]
    pub ETSI_DmxLvl_present: UCHAR,
    #[doc = "< Center downmix level (0...7, according to table)"]
    pub centerMixLevel: SCHAR,
    #[doc = "< Surround downmix level (0...7, according to"]
    #[doc = "table)"]
    pub surroundMixLevel: SCHAR,
    #[doc = "< Indication for Dolby Surround Encoding Mode."]
    #[doc = "- 0: Dolby Surround mode not indicated"]
    #[doc = "- 1: 2-ch audio part is not Dolby surround encoded"]
    #[doc = "- 2: 2-ch audio part is Dolby surround encoded"]
    pub dolbySurroundMode: UCHAR,
    #[doc = "< Indicatin for DRC Presentation Mode."]
    #[doc = "- 0: Presentation mode not inticated"]
    #[doc = "- 1: Presentation mode 1"]
    #[doc = "- 2: Presentation mode 2"]
    pub drcPresentationMode: UCHAR,
    pub ExtMetaData: AACENC_MetaData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AACENC_MetaData__bindgen_ty_1 {
    pub extAncDataEnable: UCHAR,
    pub extDownmixLevelEnable: UCHAR,
    pub extDownmixLevel_A: UCHAR,
    pub extDownmixLevel_B: UCHAR,
    pub dmxGainEnable: UCHAR,
    pub dmxGain5: INT,
    pub dmxGain2: INT,
    pub lfeDmxEnable: UCHAR,
    pub lfeDmxLevel: UCHAR,
}
#[test]
fn bindgen_test_layout_AACENC_MetaData__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<AACENC_MetaData__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(AACENC_MetaData__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<AACENC_MetaData__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(AACENC_MetaData__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).extAncDataEnable as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(extAncDataEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).extDownmixLevelEnable
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(extDownmixLevelEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).extDownmixLevel_A as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(extDownmixLevel_A)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).extDownmixLevel_B as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(extDownmixLevel_B)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).dmxGainEnable as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(dmxGainEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).dmxGain5 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(dmxGain5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).dmxGain2 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(dmxGain2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).lfeDmxEnable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(lfeDmxEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData__bindgen_ty_1>())).lfeDmxLevel as *const _
                as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData__bindgen_ty_1),
            "::",
            stringify!(lfeDmxLevel)
        )
    );
}
#[test]
fn bindgen_test_layout_AACENC_MetaData() {
    assert_eq!(
        ::std::mem::size_of::<AACENC_MetaData>(),
        52usize,
        concat!("Size of: ", stringify!(AACENC_MetaData))
    );
    assert_eq!(
        ::std::mem::align_of::<AACENC_MetaData>(),
        4usize,
        concat!("Alignment of ", stringify!(AACENC_MetaData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_MetaData>())).drc_profile as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(drc_profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_MetaData>())).comp_profile as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(comp_profile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).drc_TargetRefLevel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(drc_TargetRefLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).comp_TargetRefLevel as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(comp_TargetRefLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).prog_ref_level_present as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(prog_ref_level_present)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_MetaData>())).prog_ref_level as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(prog_ref_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).PCE_mixdown_idx_present as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(PCE_mixdown_idx_present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).ETSI_DmxLvl_present as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(ETSI_DmxLvl_present)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_MetaData>())).centerMixLevel as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(centerMixLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).surroundMixLevel as *const _ as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(surroundMixLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).dolbySurroundMode as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(dolbySurroundMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AACENC_MetaData>())).drcPresentationMode as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(drcPresentationMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AACENC_MetaData>())).ExtMetaData as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AACENC_MetaData),
            "::",
            stringify!(ExtMetaData)
        )
    );
}
#[doc = "< Do not trigger initialization."]
pub const AACENC_CTRLFLAGS_AACENC_INIT_NONE: AACENC_CTRLFLAGS = 0;
pub const AACENC_CTRLFLAGS_AACENC_INIT_CONFIG: AACENC_CTRLFLAGS = 1;
#[doc = "< Reset all encoder modules history buffer."]
pub const AACENC_CTRLFLAGS_AACENC_INIT_STATES: AACENC_CTRLFLAGS = 2;
pub const AACENC_CTRLFLAGS_AACENC_INIT_TRANSPORT: AACENC_CTRLFLAGS = 4096;
pub const AACENC_CTRLFLAGS_AACENC_RESET_INBUFFER: AACENC_CTRLFLAGS = 8192;
#[doc = "< Initialize all."]
pub const AACENC_CTRLFLAGS_AACENC_INIT_ALL: AACENC_CTRLFLAGS = 65535;
#[doc = " AAC encoder control flags."]
#[doc = ""]
#[doc = " In interaction with the ::AACENC_CONTROL_STATE parameter it is possible to"]
#[doc = " get information about the internal initialization process. It is also"]
#[doc = " possible to overwrite the internal state from extern when necessary."]
pub type AACENC_CTRLFLAGS = u32;
pub const AACENC_PARAM_AACENC_AOT: AACENC_PARAM = 256;
#[doc = "< Total encoder bitrate. This parameter is"]
#[doc = "mandatory and interacts with ::AACENC_BITRATEMODE."]
#[doc = "- CBR: Bitrate in bits/second."]
#[doc = "- VBR: Variable bitrate. Bitrate argument will"]
#[doc = "be ignored. See \\ref suppBitrates for details."]
pub const AACENC_PARAM_AACENC_BITRATE: AACENC_PARAM = 257;
#[doc = "< Bitrate mode. Configuration can be different"]
#[doc = "kind of bitrate configurations:"]
#[doc = "- 0: Constant bitrate, use bitrate according"]
#[doc = "to ::AACENC_BITRATE. (default) Within none"]
#[doc = "LD/ELD ::AUDIO_OBJECT_TYPE, the CBR mode makes"]
#[doc = "use of full allowed bitreservoir. In contrast,"]
#[doc = "at Low-Delay ::AUDIO_OBJECT_TYPE the"]
#[doc = "bitreservoir is kept very small."]
#[doc = "- 1: Variable bitrate mode, \\ref vbrmode"]
#[doc = "\"very low bitrate\"."]
#[doc = "- 2: Variable bitrate mode, \\ref vbrmode"]
#[doc = "\"low bitrate\"."]
#[doc = "- 3: Variable bitrate mode, \\ref vbrmode"]
#[doc = "\"medium bitrate\"."]
#[doc = "- 4: Variable bitrate mode, \\ref vbrmode"]
#[doc = "\"high bitrate\"."]
#[doc = "- 5: Variable bitrate mode, \\ref vbrmode"]
#[doc = "\"very high bitrate\"."]
pub const AACENC_PARAM_AACENC_BITRATEMODE: AACENC_PARAM = 258;
#[doc = "< Audio input data sampling rate. Encoder"]
#[doc = "supports following sampling rates: 8000, 11025,"]
#[doc = "12000, 16000, 22050, 24000, 32000, 44100,"]
#[doc = "48000, 64000, 88200, 96000"]
pub const AACENC_PARAM_AACENC_SAMPLERATE: AACENC_PARAM = 259;
#[doc = "< Configure SBR independently of the chosen Audio"]
#[doc = "Object Type ::AUDIO_OBJECT_TYPE. This parameter"]
#[doc = "is for ELD audio object type only."]
#[doc = "- -1: Use ELD SBR auto configurator (default)."]
#[doc = "- 0: Disable Spectral Band Replication."]
#[doc = "- 1: Enable Spectral Band Replication."]
pub const AACENC_PARAM_AACENC_SBR_MODE: AACENC_PARAM = 260;
pub const AACENC_PARAM_AACENC_GRANULE_LENGTH: AACENC_PARAM = 261;
#[doc = "< Set explicit channel mode. Channel mode must"]
#[doc = "match with number of input channels."]
#[doc = "- 1-7, 11,12,14 and 33,34: MPEG channel"]
#[doc = "modes supported, see ::CHANNEL_MODE in"]
#[doc = "FDK_audio.h."]
pub const AACENC_PARAM_AACENC_CHANNELMODE: AACENC_PARAM = 262;
pub const AACENC_PARAM_AACENC_CHANNELORDER: AACENC_PARAM = 263;
pub const AACENC_PARAM_AACENC_SBR_RATIO: AACENC_PARAM = 264;
pub const AACENC_PARAM_AACENC_AFTERBURNER: AACENC_PARAM = 512;
#[doc = "< Core encoder audio bandwidth:"]
#[doc = "- 0: Determine audio bandwidth internally"]
#[doc = "(default, see chapter \\ref BEHAVIOUR_BANDWIDTH)."]
#[doc = "- 1 to fs/2: Audio bandwidth in Hertz. Limited"]
#[doc = "to 20kHz max. Not usable if SBR is active. This"]
#[doc = "setting is for experts only, better do not touch"]
#[doc = "this value to avoid degraded audio quality."]
pub const AACENC_PARAM_AACENC_BANDWIDTH: AACENC_PARAM = 515;
pub const AACENC_PARAM_AACENC_PEAK_BITRATE: AACENC_PARAM = 519;
#[doc = "< Transport type to be used. See ::TRANSPORT_TYPE"]
#[doc = "in FDK_audio.h. Following types can be configured"]
#[doc = "in encoder library:"]
#[doc = "- 0: raw access units"]
#[doc = "- 1: ADIF bitstream format"]
#[doc = "- 2: ADTS bitstream format"]
#[doc = "- 6: Audio Mux Elements (LATM) with"]
#[doc = "muxConfigPresent = 1"]
#[doc = "- 7: Audio Mux Elements (LATM) with"]
#[doc = "muxConfigPresent = 0, out of band StreamMuxConfig"]
#[doc = "- 10: Audio Sync Stream (LOAS)"]
pub const AACENC_PARAM_AACENC_TRANSMUX: AACENC_PARAM = 768;
pub const AACENC_PARAM_AACENC_HEADER_PERIOD: AACENC_PARAM = 769;
pub const AACENC_PARAM_AACENC_SIGNALING_MODE: AACENC_PARAM = 770;
pub const AACENC_PARAM_AACENC_TPSUBFRAMES: AACENC_PARAM = 771;
pub const AACENC_PARAM_AACENC_AUDIOMUXVER: AACENC_PARAM = 772;
#[doc = "< Configure protection in transport layer:"]
#[doc = "- 0: No protection. (default)"]
#[doc = "- 1: CRC active for ADTS transport format."]
pub const AACENC_PARAM_AACENC_PROTECTION: AACENC_PARAM = 774;
pub const AACENC_PARAM_AACENC_ANCILLARY_BITRATE: AACENC_PARAM = 1280;
#[doc = "< Configure Meta Data. See ::AACENC_MetaData"]
#[doc = "for further details:"]
#[doc = "- 0: Do not embed any metadata."]
#[doc = "- 1: Embed dynamic_range_info metadata."]
#[doc = "- 2: Embed dynamic_range_info and"]
#[doc = "ancillary_data metadata."]
#[doc = "- 3: Embed ancillary_data metadata."]
pub const AACENC_PARAM_AACENC_METADATA_MODE: AACENC_PARAM = 1536;
pub const AACENC_PARAM_AACENC_CONTROL_STATE: AACENC_PARAM = 65280;
#[doc = "< ------"]
pub const AACENC_PARAM_AACENC_NONE: AACENC_PARAM = 65535;
#[doc = " \\brief  AAC encoder setting parameters."]
#[doc = ""]
#[doc = " Use aacEncoder_SetParam() function to configure, or use aacEncoder_GetParam()"]
#[doc = " function to read the internal status of the following parameters."]
pub type AACENC_PARAM = u32;
extern "C" {
    #[doc = " \\brief  Open an instance of the encoder."]
    #[doc = ""]
    #[doc = " Allocate memory for an encoder instance with a functional range denoted by"]
    #[doc = " the function parameters. Preinitialize encoder instance with default"]
    #[doc = " configuration."]
    #[doc = ""]
    #[doc = " \\param phAacEncoder  A pointer to an encoder handle. Initialized on return."]
    #[doc = " \\param encModules    Specify encoder modules to be supported in this encoder"]
    #[doc = " instance:"]
    #[doc = "                      - 0x0: Allocate memory for all available encoder"]
    #[doc = " modules."]
    #[doc = "                      - else: Select memory allocation regarding encoder"]
    #[doc = " modules. Following flags are possible and can be combined."]
    #[doc = "                              - 0x01: AAC module."]
    #[doc = "                              - 0x02: SBR module."]
    #[doc = "                              - 0x04: PS module."]
    #[doc = "                              - 0x08: MPS module."]
    #[doc = "                              - 0x10: Metadata module."]
    #[doc = "                              - example: (0x01|0x02|0x04|0x08|0x10) allocates"]
    #[doc = " all modules and is equivalent to default configuration denotet by 0x0."]
    #[doc = " \\param maxChannels   Number of channels to be allocated. This parameter can"]
    #[doc = " be used in different ways:"]
    #[doc = "                      - 0: Allocate maximum number of AAC and SBR channels as"]
    #[doc = " supported by the library."]
    #[doc = "                      - nChannels: Use same maximum number of channels for"]
    #[doc = " allocating memory in AAC and SBR module."]
    #[doc = "                      - nChannels | (nSbrCh<<8): Number of SBR channels can be"]
    #[doc = " different to AAC channels to save data memory."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = "          - AACENC_OK, on succes."]
    #[doc = "          - AACENC_INVALID_HANDLE, AACENC_MEMORY_ERROR, AACENC_INVALID_CONFIG,"]
    #[doc = " on failure."]
    #[link_name = "\u{1}_aacEncOpen"]
    pub fn aacEncOpen(
        phAacEncoder: *mut HANDLE_AACENCODER,
        encModules: UINT,
        maxChannels: UINT,
    ) -> AACENC_ERROR;
}
extern "C" {
    #[doc = " \\brief  Close the encoder instance."]
    #[doc = ""]
    #[doc = " Deallocate encoder instance and free whole memory."]
    #[doc = ""]
    #[doc = " \\param phAacEncoder  Pointer to the encoder handle to be deallocated."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = "          - AACENC_OK, on success."]
    #[doc = "          - AACENC_INVALID_HANDLE, on failure."]
    #[link_name = "\u{1}_aacEncClose"]
    pub fn aacEncClose(phAacEncoder: *mut HANDLE_AACENCODER) -> AACENC_ERROR;
}
extern "C" {
    #[doc = " \\brief Encode audio data."]
    #[doc = ""]
    #[doc = " This function is mainly for encoding audio data. In addition the function can"]
    #[doc = " be used for an encoder (re)configuration process."]
    #[doc = " - PCM input data will be retrieved from external input buffer until the fill"]
    #[doc = " level allows encoding a single frame. This functionality allows an external"]
    #[doc = " buffer with reduced size in comparison to the AAC or HE-AAC audio frame"]
    #[doc = " length."]
    #[doc = " - If the value of the input samples argument is zero, just internal"]
    #[doc = " reinitialization will be applied if it is requested."]
    #[doc = " - At the end of a file the flushing process can be triggerd via setting the"]
    #[doc = " value of the input samples argument to -1. The encoder delay lines are fully"]
    #[doc = " flushed when the encoder returns no valid bitstream data"]
    #[doc = " AACENC_OutArgs::numOutBytes. Furthermore the end of file is signaled by the"]
    #[doc = " return value AACENC_ENCODE_EOF."]
    #[doc = " - If an error occured in the previous frame or any of the encoder parameters"]
    #[doc = " changed, an internal reinitialization process will be applied before encoding"]
    #[doc = " the incoming audio samples."]
    #[doc = " - The function can also be used for an independent reconfiguration process"]
    #[doc = " without encoding. The first parameter has to be a valid encoder handle and"]
    #[doc = " all other parameters can be set to NULL."]
    #[doc = " - If the size of the external bitbuffer in outBufDesc is not sufficient for"]
    #[doc = " writing the whole bitstream, an internal error will be the return value and a"]
    #[doc = " reconfiguration will be triggered."]
    #[doc = ""]
    #[doc = " \\param hAacEncoder           A valid AAC encoder handle."]
    #[doc = " \\param inBufDesc             Input buffer descriptor, see AACENC_BufDesc:"]
    #[doc = "                              - At least one input buffer with audio data is"]
    #[doc = " expected."]
    #[doc = "                              - Optionally a second input buffer with"]
    #[doc = " ancillary data can be fed."]
    #[doc = " \\param outBufDesc            Output buffer descriptor, see AACENC_BufDesc:"]
    #[doc = "                              - Provide one output buffer for the encoded"]
    #[doc = " bitstream."]
    #[doc = " \\param inargs                Input arguments, see AACENC_InArgs."]
    #[doc = " \\param outargs               Output arguments, AACENC_OutArgs."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = "          - AACENC_OK, on success."]
    #[doc = "          - AACENC_INVALID_HANDLE, AACENC_ENCODE_ERROR, on failure in encoding"]
    #[doc = " process."]
    #[doc = "          - AACENC_INVALID_CONFIG, AACENC_INIT_ERROR, AACENC_INIT_AAC_ERROR,"]
    #[doc = " AACENC_INIT_SBR_ERROR, AACENC_INIT_TP_ERROR, AACENC_INIT_META_ERROR,"]
    #[doc = " AACENC_INIT_MPS_ERROR, on failure in encoder initialization."]
    #[doc = "          - AACENC_UNSUPPORTED_PARAMETER, on incorrect input or output buffer"]
    #[doc = " descriptor initialization."]
    #[doc = "          - AACENC_ENCODE_EOF, when flushing fully concluded."]
    #[link_name = "\u{1}_aacEncEncode"]
    pub fn aacEncEncode(
        hAacEncoder: HANDLE_AACENCODER,
        inBufDesc: *const AACENC_BufDesc,
        outBufDesc: *const AACENC_BufDesc,
        inargs: *const AACENC_InArgs,
        outargs: *mut AACENC_OutArgs,
    ) -> AACENC_ERROR;
}
extern "C" {
    #[doc = " \\brief  Acquire info about present encoder instance."]
    #[doc = ""]
    #[doc = " This function retrieves information of the encoder configuration. In addition"]
    #[doc = " to informative internal states, a configuration data block of the current"]
    #[doc = " encoder settings will be returned. The format is either Audio Specific Config"]
    #[doc = " in case of Raw Packets transport format or StreamMuxConfig in case of"]
    #[doc = " LOAS/LATM transport format. The configuration data block is binary coded as"]
    #[doc = " specified in ISO/IEC 14496-3 (MPEG-4 audio), to be used directly for MPEG-4"]
    #[doc = " File Format or RFC3016 or RFC3640 applications."]
    #[doc = ""]
    #[doc = " \\param hAacEncoder           A valid AAC encoder handle."]
    #[doc = " \\param pInfo                 Pointer to AACENC_InfoStruct. Filled on return."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = "          - AACENC_OK, on succes."]
    #[doc = "          - AACENC_INIT_ERROR, on failure."]
    #[link_name = "\u{1}_aacEncInfo"]
    pub fn aacEncInfo(
        hAacEncoder: HANDLE_AACENCODER,
        pInfo: *mut AACENC_InfoStruct,
    ) -> AACENC_ERROR;
}
extern "C" {
    #[doc = " \\brief  Set one single AAC encoder parameter."]
    #[doc = ""]
    #[doc = " This function allows configuration of all encoder parameters specified in"]
    #[doc = " ::AACENC_PARAM. Each parameter must be set with a separate function call. An"]
    #[doc = " internal validation of the configuration value range will be done and an"]
    #[doc = " internal reconfiguration will be signaled. The actual configuration adoption"]
    #[doc = " is part of the subsequent aacEncEncode() call."]
    #[doc = ""]
    #[doc = " \\param hAacEncoder           A valid AAC encoder handle."]
    #[doc = " \\param param                 Parameter to be set. See ::AACENC_PARAM."]
    #[doc = " \\param value                 Parameter value. See parameter description in"]
    #[doc = " ::AACENC_PARAM."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = "          - AACENC_OK, on success."]
    #[doc = "          - AACENC_INVALID_HANDLE, AACENC_UNSUPPORTED_PARAMETER,"]
    #[doc = " AACENC_INVALID_CONFIG, on failure."]
    #[link_name = "\u{1}_aacEncoder_SetParam"]
    pub fn aacEncoder_SetParam(
        hAacEncoder: HANDLE_AACENCODER,
        param: AACENC_PARAM,
        value: UINT,
    ) -> AACENC_ERROR;
}
extern "C" {
    #[doc = " \\brief  Get one single AAC encoder parameter."]
    #[doc = ""]
    #[doc = " This function is the complement to aacEncoder_SetParam(). After encoder"]
    #[doc = " reinitialization with user defined settings, the internal status can be"]
    #[doc = " obtained of each parameter, specified with ::AACENC_PARAM."]
    #[doc = ""]
    #[doc = " \\param hAacEncoder           A valid AAC encoder handle."]
    #[doc = " \\param param                 Parameter to be returned. See ::AACENC_PARAM."]
    #[doc = ""]
    #[doc = " \\return  Internal configuration value of specifed parameter ::AACENC_PARAM."]
    #[link_name = "\u{1}_aacEncoder_GetParam"]
    pub fn aacEncoder_GetParam(hAacEncoder: HANDLE_AACENCODER, param: AACENC_PARAM) -> UINT;
}
extern "C" {
    #[doc = " \\brief  Get information about encoder library build."]
    #[doc = ""]
    #[doc = " Fill a given LIB_INFO structure with library version information."]
    #[doc = ""]
    #[doc = " \\param info  Pointer to an allocated LIB_INFO struct."]
    #[doc = ""]
    #[doc = " \\return"]
    #[doc = "          - AACENC_OK, on success."]
    #[doc = "          - AACENC_INVALID_HANDLE, AACENC_INIT_ERROR, on failure."]
    #[link_name = "\u{1}_aacEncGetLibInfo"]
    pub fn aacEncGetLibInfo(info: *mut LIB_INFO) -> AACENC_ERROR;
}
